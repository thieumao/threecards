{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport { KEY_PREFIX } from './constants';\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage';\nexport default function getStoredState(config, onComplete) {\n  var storage = config.storage || createAsyncLocalStorage('local');\n  var deserializer = config.serialize === false ? function (data) {\n    return data;\n  } : defaultDeserializer;\n  var blacklist = config.blacklist || [];\n  var whitelist = config.whitelist || false;\n  var transforms = config.transforms || [];\n  var keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX; // fallback getAllKeys to `keys` if present (LocalForage compatability)\n\n  if (storage.keys && !storage.getAllKeys) storage = _extends({}, storage, {\n    getAllKeys: storage.keys\n  });\n  var restoredState = {};\n  var completionCount = 0;\n  storage.getAllKeys(function (err, allKeys) {\n    if (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error in storage.getAllKeys');\n      complete(err);\n    }\n\n    var persistKeys = allKeys.filter(function (key) {\n      return key.indexOf(keyPrefix) === 0;\n    }).map(function (key) {\n      return key.slice(keyPrefix.length);\n    });\n    var keysToRestore = persistKeys.filter(passWhitelistBlacklist);\n    var restoreCount = keysToRestore.length;\n    if (restoreCount === 0) complete(null, restoredState);\n    keysToRestore.forEach(function (key) {\n      storage.getItem(createStorageKey(key), function (err, serialized) {\n        if (err && process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);else restoredState[key] = rehydrate(key, serialized);\n        completionCount += 1;\n        if (completionCount === restoreCount) complete(null, restoredState);\n      });\n    });\n  });\n\n  function rehydrate(key, serialized) {\n    var state = null;\n\n    try {\n      var data = deserializer(serialized);\n      state = transforms.reduceRight(function (subState, transformer) {\n        return transformer.out(subState, key);\n      }, data);\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);\n    }\n\n    return state;\n  }\n\n  function complete(err, restoredState) {\n    onComplete(err, restoredState);\n  }\n\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false;\n    if (blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n\n  function createStorageKey(key) {\n    return '' + keyPrefix + key;\n  }\n\n  if (typeof onComplete !== 'function' && !!Promise) {\n    return new Promise(function (resolve, reject) {\n      onComplete = function onComplete(err, restoredState) {\n        if (err) reject(err);else resolve(restoredState);\n      };\n    });\n  }\n}\n\nfunction defaultDeserializer(serial) {\n  return JSON.parse(serial);\n}","map":{"version":3,"sources":["/Users/thieunguyen/Desktop/Project/ReactJS/web-ets-2020/node_modules/redux-offline/node_modules/redux-persist/es/getStoredState.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","KEY_PREFIX","createAsyncLocalStorage","getStoredState","config","onComplete","storage","deserializer","serialize","data","defaultDeserializer","blacklist","whitelist","transforms","keyPrefix","undefined","keys","getAllKeys","restoredState","completionCount","err","allKeys","process","env","NODE_ENV","console","warn","complete","persistKeys","filter","indexOf","map","slice","keysToRestore","passWhitelistBlacklist","restoreCount","forEach","getItem","createStorageKey","serialized","rehydrate","state","reduceRight","subState","transformer","out","Promise","resolve","reject","serial","JSON","parse"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEA,SAASS,UAAT,QAA2B,aAA3B;AACA,OAAOC,uBAAP,MAAoC,8BAApC;AAEA,eAAe,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,UAAhC,EAA4C;AACzD,MAAIC,OAAO,GAAGF,MAAM,CAACE,OAAP,IAAkBJ,uBAAuB,CAAC,OAAD,CAAvD;AACA,MAAIK,YAAY,GAAGH,MAAM,CAACI,SAAP,KAAqB,KAArB,GAA6B,UAAUC,IAAV,EAAgB;AAC9D,WAAOA,IAAP;AACD,GAFkB,GAEfC,mBAFJ;AAGA,MAAIC,SAAS,GAAGP,MAAM,CAACO,SAAP,IAAoB,EAApC;AACA,MAAIC,SAAS,GAAGR,MAAM,CAACQ,SAAP,IAAoB,KAApC;AACA,MAAIC,UAAU,GAAGT,MAAM,CAACS,UAAP,IAAqB,EAAtC;AACA,MAAIC,SAAS,GAAGV,MAAM,CAACU,SAAP,KAAqBC,SAArB,GAAiCX,MAAM,CAACU,SAAxC,GAAoDb,UAApE,CARyD,CAUzD;;AACA,MAAIK,OAAO,CAACU,IAAR,IAAgB,CAACV,OAAO,CAACW,UAA7B,EAAyCX,OAAO,GAAGjB,QAAQ,CAAC,EAAD,EAAKiB,OAAL,EAAc;AAAEW,IAAAA,UAAU,EAAEX,OAAO,CAACU;AAAtB,GAAd,CAAlB;AAEzC,MAAIE,aAAa,GAAG,EAApB;AACA,MAAIC,eAAe,GAAG,CAAtB;AAEAb,EAAAA,OAAO,CAACW,UAAR,CAAmB,UAAUG,GAAV,EAAeC,OAAf,EAAwB;AACzC,QAAID,GAAJ,EAAS;AACP,UAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2CC,OAAO,CAACC,IAAR,CAAa,2DAAb;AAC3CC,MAAAA,QAAQ,CAACP,GAAD,CAAR;AACD;;AAED,QAAIQ,WAAW,GAAGP,OAAO,CAACQ,MAAR,CAAe,UAAUhC,GAAV,EAAe;AAC9C,aAAOA,GAAG,CAACiC,OAAJ,CAAYhB,SAAZ,MAA2B,CAAlC;AACD,KAFiB,EAEfiB,GAFe,CAEX,UAAUlC,GAAV,EAAe;AACpB,aAAOA,GAAG,CAACmC,KAAJ,CAAUlB,SAAS,CAACnB,MAApB,CAAP;AACD,KAJiB,CAAlB;AAKA,QAAIsC,aAAa,GAAGL,WAAW,CAACC,MAAZ,CAAmBK,sBAAnB,CAApB;AAEA,QAAIC,YAAY,GAAGF,aAAa,CAACtC,MAAjC;AACA,QAAIwC,YAAY,KAAK,CAArB,EAAwBR,QAAQ,CAAC,IAAD,EAAOT,aAAP,CAAR;AACxBe,IAAAA,aAAa,CAACG,OAAd,CAAsB,UAAUvC,GAAV,EAAe;AACnCS,MAAAA,OAAO,CAAC+B,OAAR,CAAgBC,gBAAgB,CAACzC,GAAD,CAAhC,EAAuC,UAAUuB,GAAV,EAAemB,UAAf,EAA2B;AAChE,YAAInB,GAAG,IAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAApC,EAAkDC,OAAO,CAACC,IAAR,CAAa,6DAAb,EAA4E7B,GAA5E,EAAiFuB,GAAjF,EAAlD,KAA6IF,aAAa,CAACrB,GAAD,CAAb,GAAqB2C,SAAS,CAAC3C,GAAD,EAAM0C,UAAN,CAA9B;AAC7IpB,QAAAA,eAAe,IAAI,CAAnB;AACA,YAAIA,eAAe,KAAKgB,YAAxB,EAAsCR,QAAQ,CAAC,IAAD,EAAOT,aAAP,CAAR;AACvC,OAJD;AAKD,KAND;AAOD,GAtBD;;AAwBA,WAASsB,SAAT,CAAmB3C,GAAnB,EAAwB0C,UAAxB,EAAoC;AAClC,QAAIE,KAAK,GAAG,IAAZ;;AAEA,QAAI;AACF,UAAIhC,IAAI,GAAGF,YAAY,CAACgC,UAAD,CAAvB;AACAE,MAAAA,KAAK,GAAG5B,UAAU,CAAC6B,WAAX,CAAuB,UAAUC,QAAV,EAAoBC,WAApB,EAAiC;AAC9D,eAAOA,WAAW,CAACC,GAAZ,CAAgBF,QAAhB,EAA0B9C,GAA1B,CAAP;AACD,OAFO,EAELY,IAFK,CAAR;AAGD,KALD,CAKE,OAAOW,GAAP,EAAY;AACZ,UAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2CC,OAAO,CAACC,IAAR,CAAa,6DAAb,EAA4E7B,GAA5E,EAAiFuB,GAAjF;AAC5C;;AAED,WAAOqB,KAAP;AACD;;AAED,WAASd,QAAT,CAAkBP,GAAlB,EAAuBF,aAAvB,EAAsC;AACpCb,IAAAA,UAAU,CAACe,GAAD,EAAMF,aAAN,CAAV;AACD;;AAED,WAASgB,sBAAT,CAAgCrC,GAAhC,EAAqC;AACnC,QAAIe,SAAS,IAAIA,SAAS,CAACkB,OAAV,CAAkBjC,GAAlB,MAA2B,CAAC,CAA7C,EAAgD,OAAO,KAAP;AAChD,QAAIc,SAAS,CAACmB,OAAV,CAAkBjC,GAAlB,MAA2B,CAAC,CAAhC,EAAmC,OAAO,KAAP;AACnC,WAAO,IAAP;AACD;;AAED,WAASyC,gBAAT,CAA0BzC,GAA1B,EAA+B;AAC7B,WAAO,KAAKiB,SAAL,GAAiBjB,GAAxB;AACD;;AAED,MAAI,OAAOQ,UAAP,KAAsB,UAAtB,IAAoC,CAAC,CAACyC,OAA1C,EAAmD;AACjD,WAAO,IAAIA,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C3C,MAAAA,UAAU,GAAG,SAASA,UAAT,CAAoBe,GAApB,EAAyBF,aAAzB,EAAwC;AACnD,YAAIE,GAAJ,EAAS4B,MAAM,CAAC5B,GAAD,CAAN,CAAT,KAA0B2B,OAAO,CAAC7B,aAAD,CAAP;AAC3B,OAFD;AAGD,KAJM,CAAP;AAKD;AACF;;AAED,SAASR,mBAAT,CAA6BuC,MAA7B,EAAqC;AACnC,SAAOC,IAAI,CAACC,KAAL,CAAWF,MAAX,CAAP;AACD","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { KEY_PREFIX } from './constants';\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage';\n\nexport default function getStoredState(config, onComplete) {\n  var storage = config.storage || createAsyncLocalStorage('local');\n  var deserializer = config.serialize === false ? function (data) {\n    return data;\n  } : defaultDeserializer;\n  var blacklist = config.blacklist || [];\n  var whitelist = config.whitelist || false;\n  var transforms = config.transforms || [];\n  var keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX;\n\n  // fallback getAllKeys to `keys` if present (LocalForage compatability)\n  if (storage.keys && !storage.getAllKeys) storage = _extends({}, storage, { getAllKeys: storage.keys });\n\n  var restoredState = {};\n  var completionCount = 0;\n\n  storage.getAllKeys(function (err, allKeys) {\n    if (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error in storage.getAllKeys');\n      complete(err);\n    }\n\n    var persistKeys = allKeys.filter(function (key) {\n      return key.indexOf(keyPrefix) === 0;\n    }).map(function (key) {\n      return key.slice(keyPrefix.length);\n    });\n    var keysToRestore = persistKeys.filter(passWhitelistBlacklist);\n\n    var restoreCount = keysToRestore.length;\n    if (restoreCount === 0) complete(null, restoredState);\n    keysToRestore.forEach(function (key) {\n      storage.getItem(createStorageKey(key), function (err, serialized) {\n        if (err && process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);else restoredState[key] = rehydrate(key, serialized);\n        completionCount += 1;\n        if (completionCount === restoreCount) complete(null, restoredState);\n      });\n    });\n  });\n\n  function rehydrate(key, serialized) {\n    var state = null;\n\n    try {\n      var data = deserializer(serialized);\n      state = transforms.reduceRight(function (subState, transformer) {\n        return transformer.out(subState, key);\n      }, data);\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);\n    }\n\n    return state;\n  }\n\n  function complete(err, restoredState) {\n    onComplete(err, restoredState);\n  }\n\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false;\n    if (blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n\n  function createStorageKey(key) {\n    return '' + keyPrefix + key;\n  }\n\n  if (typeof onComplete !== 'function' && !!Promise) {\n    return new Promise(function (resolve, reject) {\n      onComplete = function onComplete(err, restoredState) {\n        if (err) reject(err);else resolve(restoredState);\n      };\n    });\n  }\n}\n\nfunction defaultDeserializer(serial) {\n  return JSON.parse(serial);\n}"]},"metadata":{},"sourceType":"module"}